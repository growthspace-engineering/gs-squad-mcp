<!-- 6ea95e55-5b2a-4dcb-a132-d14aebb47367 20cca97e-7ae1-4115-a668-759b6a98c1ac -->
# Squad Dashboard & Telemetry Implementation Plan

## 1. Context & Goals

- Implement the Phase 02 blueprint for a **SQLite-backed squad telemetry DB** plus a **TUI dashboard**, on top of the existing `gs-squad-mcp` MCP (as implemented in `src/core/mcp/squad.service.ts` and `src/cli/mcp-cli.command.ts`).
- Keep the repo **always green** (lint, unit, e2e) with **small, atomic commits**.
- Introduce explicit **human-in-the-loop checkpoints** for visual TUI review and UX feedback.
- Align with any orchestrator constraints in `orchestrator-rules.mdc` (to be located and reviewed) without breaking current MCP contracts more than necessary.

## 2. Discovery & Design Alignment

- **2.1 Orchestrator rules & blueprint alignment**
- Locate and read `orchestrator-rules.mdc` (likely under `.cursor/rules/` or similar) to understand how orchestrators call `list_roles` and `start_squad_members`, and any expectations around telemetry or chat IDs.
- Cross-check the Phase 02 blueprint assumptions (originator resolution, `orchestratorChatId`, `workspaceId`, interactive CLI usage) against:
  - `src/core/mcp/contracts/*.ts` (payload/response shapes)
  - `src/cli/mcp-cli.command.ts` (MCP JSON-RPC schemas and tool list).
- Decide how to extend the `start_squad_members` input schema to carry originator context **without breaking existing callers** (e.g., optional new fields).

- **2.2 Telemetry integration strategy**
- Confirm there is **no existing DB/TypeORM usage** (current code is process-local and stateless per call).
- Choose where telemetry lives:
  - Entities + TypeORM config under a small Nest module (e.g. `src/nest/db.module.ts`), plus entities in `src/nest/entities/` or `src/core/telemetry/`.
  - A dedicated service (e.g. `SquadTelemetryService`) that is injected into `SquadService` and **never** used directly by the CLI.
- Decide migration tooling (TypeORM CLI vs simple `DataSource`-driven migrations), and confirm it fits existing build/test scripts.

## 3. Phase 1 – Telemetry Persistence in MCP (SQLite + TypeORM)

- **3.1 DB path resolution & configuration**
- Implement a shared utility (e.g. `src/shared/squad-db-path.ts`) that resolves `SQUAD_DB_PATH` with homedir fallback per blueprint:
  - `SQUAD_DB_PATH` if set, else `~/.gs-squad-mcp/squad.db`, ensuring `~/.gs-squad-mcp` exists.
- Wire `TypeOrmModule.forRootAsync` into `AppModule` (or a dedicated DB module imported by `AppModule`) using that utility and the blueprint configuration:
  - SQLite DB, `synchronize: false`, `migrationsRun: true`, and entity + migration lists.
- Add a minimal migration setup (config + first migration) for the initial schema.

- **3.2 Entities & migrations**
- Implement TypeORM entities matching the blueprint in a single, well-named folder (e.g. `src/nest/entities/`):
  - `SessionEntity` (`sessions`): `originatorId`, `orchestratorChatId?`, `workspaceId?`, `createdAt`, `lastActivityAt`.
  - `SquadEntity` (`squads`): `squadId`, `originatorId` FK, `label`, `createdAt`.
  - `AgentEntity` (`agents`): `agentId`, `squadId` FK, `roleName`, `prompt?`, `status`, `result?`, `error?`, `startedAt`, `finishedAt?`.
- Create an initial migration that builds the 3 tables and foreign keys, using TypeORM migrations (no `synchronize: true` in production config).

- **3.3 `SquadTelemetryService`**
- Implement a Nest injectable `SquadTelemetryService` (e.g. `src/core/telemetry/squad-telemetry.service.ts`):
  - `ensureSession({ orchestratorChatId?, workspaceId? }): Promise<string>` that derives `originatorId` per blueprint (chat ID → workspace ID → `process.cwd()`), creates/updates the session row, and returns `originatorId`.
  - `createSquad(originatorId, label): Promise<SquadEntity>` that inserts a squad, updates `lastActivityAt` via a `touchSession` helper.
  - `createAgent(squadId, roleName, prompt): Promise<AgentEntity>` that inserts an agent with status `starting`.
  - `updateAgentStatus(originatorId, agentId, patch)` that updates the agent status/result/error and `lastActivityAt`.
- Unit-test `SquadTelemetryService` with an in-memory SQLite or a test DB file, verifying originator resolution and `lastActivityAt` updates.

- **3.4 Wiring telemetry into `SquadService` & contracts**
- Extend both payload contracts to include originator context (optional) based on orchestrator rules and blueprint:
  - `IStartSquadMembersStatelessPayload` / `IStartSquadMembersStatefulPayload` gain `orchestratorChatId?: string`, `workspaceId?: string`.
- Update `McpCliCommand` schemas for `start_squad_members` (under `tools/list` and `tools/call`) to describe these optional fields in `inputSchema` so orchestrators can pass them.
- Inject `SquadTelemetryService` into `SquadService` and augment:
  - At the start of each `startSquadMembers*` call:
  - Call `ensureSession` with the passed context, get `originatorId`.
  - Create a squad with label built from member roles (as in the blueprint).
  - For each member execution:
  - Before spawning the process, create an `AgentEntity` with status `starting`.
  - After process completion, call `updateAgentStatus` with `done`/`error` and result/error, plus timestamps.
- Ensure that if telemetry fails (e.g. DB error), the core squad behavior either:
  - Fails fast with a clear error (strict mode), or
  - Logs and continues (best-effort mode) – choose one and document; default to fail-fast unless orchestrator rules require otherwise.

- **3.5 Tests & atomic commits (Phase 1)**
- Extend unit tests in `squad.service.spec.ts` and possibly `mcp-cli.command.spec.ts` to cover:
  - New payload fields are accepted and forwarded.
  - Telemetry methods are called with expected values (mocked repos/TypeORM).
- Add targeted tests for `SquadTelemetryService` around originator resolution, session updates, and agent status transitions.
- For each coherent slice (e.g. "entities + migration", "telemetry service", "squad wiring"), ensure:
  - `npm run lint`, `npm test`, and relevant e2e tests pass before committing.

- **3.6 Human checkpoint – DB & telemetry sanity**
- After wiring telemetry and tests, the implementation agent should:
  - Ask you to run a short manual scenario: invoke `start_squad_members` a couple of times (stateless and stateful) and then inspect the SQLite DB (via `sqlite3` or a simple script) to confirm sessions, squads, and agents look reasonable.
  - Confirm together whether the `originatorId` grouping matches your mental model (chat vs workspace vs cwd) before moving on.

## 4. Phase 2 – Basic TUI Dashboard (View-Only)

- **4.1 Package structure & tooling**
- Introduce a separate CLI package as per blueprint, e.g. `packages/gs-squad-dashboard/` with its own `package.json` and simple TS build (ts-node or tsc + `bin` entry).
- Wire it as a workspace/package in the root `package.json` if desired, but keep changes minimal and backwards-compatible.
- Add dependencies:
  - `better-sqlite3` (read-only DB client).
  - `ink` (React-based TUI), plus any minimal Ink ecosystem packages.

- **4.2 Shared DB path resolution**
- Reuse the same `SQUAD_DB_PATH` resolution logic as MCP (ideally via a small shared module that both packages can import, or via a tiny helper duplicated with tests if cross-package sharing is awkward).
- In `packages/gs-squad-dashboard/src/db.ts`:
  - Open the database in **read-only mode** using `better-sqlite3`.
  - Implement `loadFullState(): { sessions: SessionDTO[]; squads: SquadDTO[]; agents: AgentDTO[] }` that runs `SELECT * FROM sessions/squads/agents` and maps to DTOs.
  - Implement a cheap change-detection query (e.g. `SELECT MAX(lastActivityAt) FROM sessions`) for polling.

- **4.3 TUI state & layout**
- Create `TuiApp` (e.g. `src/ui/TuiApp.tsx`) using Ink with:
  - A polling hook (`setInterval` in a custom hook) that:
  - Periodically checks `MAX(lastActivityAt)`.
  - Refreshes full state only when it changes.
  - In-memory grouping by `originatorId`:
  - Build `Map<originatorId, { session, squads[], agents[] }>` sorted by `lastActivityAt` descending.
  - Layout:
  - Rows = sessions (originators); label row as `Chat: <orchestratorChatId>` or `Workspace: <workspaceId || originatorId>`.
  - Columns per row = squads sorted by `createdAt`, each showing squad label and per-agent status + truncated result/error.
- Implement an empty-state view when there are no sessions or when the DB file does not exist yet.

- **4.4 TUI CLI entry**
- Implement `src/cli.ts` with a small CLI that:
  - Resolves the DB path.
  - Checks for existence; if absent, prints a friendly message and exits with code 0.
  - Otherwise, runs the Ink app in **view-only** mode.
- Configure `bin` in the dashboard package to expose `gs-squad-dashboard`.

- **4.5 Tests & atomic commits (Phase 2)**
- Add light unit tests for:
  - `loadFullState` mapping and error handling.
  - The grouping logic that maps raw rows into the row/column model.
- Keep UI-specific tests modest (snapshot or structural tests for key layouts, not pixel-perfect).
- For each slice (DB access, state builder, minimal UI, CLI entry), ensure:
  - Root and package-level `lint`/`test` scripts pass (or add new scripts and document them) before each commit.

- **4.6 Human checkpoint – View-only TUI UX**
- Once the view-only TUI is functional, the implementation agent should:
  - Ask you to run the MCP with a few squads and then run `gs-squad-dashboard`.
  - Have you visually review:
  - Row grouping by originator.
  - Column ordering and readability of squad labels.
  - Status indicators (spinners vs checkmarks vs errors).
  - Collect your feedback on layout, colors, and density, and tweak before moving to interactive mode.

## 5. Phase 3 – Interactive TUI Mode

- **5.1 CLI flags & env validation**
- Extend the dashboard CLI (`cli.ts`) to accept `--interactive`.
- On `--interactive`:
  - Validate presence of `AGENT_CREATE_CHAT_CMD` and `AGENT_INTERACTIVE_CMD`.
  - If missing, print a clear error and exit non-zero.

- **5.2 Orchestrator chat creation & PTY**
- On interactive startup:
  - Run `AGENT_CREATE_CHAT_CMD` non-interactively, capture stdout as `orchestratorChatId`.
  - Compute `attachedOriginatorId = orchestratorChatId` and use this to pin the corresponding row later.
- Spawn a PTY via `node-pty` running `AGENT_INTERACTIVE_CMD`, passing the chat ID via env (`ORCHESTRATOR_CHAT_ID=<id>`) or an agreed CLI argument.

- **5.3 Interactive TUI layout**
- Extend `TuiApp` to support `mode="interactive"`, `attachedOriginatorId`, and a `pty` handle:
  - Top pane: the same dashboard as view-only, but rows sorted so that `originatorId === attachedOriginatorId` is always first.
  - Bottom pane: a terminal view streaming PTY output (`pty.onData`) and forwarding keyboard input (`useInput`) back to `pty.write`.
  - Sensible behavior for PTY exit (e.g., display a "session ended" message and allow quitting the TUI with a key).

- **5.4 Manual and automated checks (Phase 3)**
- Add basic tests for:
  - Interactive mode flag parsing and env validation.
  - Sorting behavior that pins `attachedOriginatorId` at the top.
- Human-in-the-loop check: the implementation agent should ask you to:
  - Configure `AGENT_CREATE_CHAT_CMD` / `AGENT_INTERACTIVE_CMD` for your orchestrator.
  - Run `gs-squad-dashboard --interactive` and confirm:
  - Chat creation works and the pinned row behaves as expected.
  - Keyboard input flows correctly to the orchestrator.
  - The experience remains usable with multiple concurrently-updating rows.

## 6. Phase 4 – Polish, Filters, and Documentation

- **6.1 Filters & CLI options**
- Add optional CLI flags to the dashboard such as:
  - `--originator <id>` to focus on one row.
  - `--workspace <path>` to filter sessions by workspace.
- Ensure these filters are purely client-side (TUI) and do not require DB schema changes.

- **6.2 UX and robustness**
- Add graceful handling for:
  - DB lock/contention errors (display a simple warning in the TUI instead of crashing).
  - Very large result/error fields (truncate with an indicator and possibly a detail pane later).
- Take another pass over colors, spacing, and symbols to keep the dashboard readable in common terminal themes.

- **6.3 Documentation & examples**
- Update `README.md` and/or create a dedicated `docs/phase 02` section:
  - Explain telemetry behavior and schema at a high level.
  - Document `SQUAD_DB_PATH`, `AGENT_CREATE_CHAT_CMD`, `AGENT_INTERACTIVE_CMD`, and the new payload fields `orchestratorChatId`/`workspaceId`.
  - Include example `start_squad_members` tool calls and example dashboard screenshots.
- Add a short "operational runbook" describing how to:
  - Point multiple MCP processes at the same DB.
  - Use the TUI for debugging squad behavior.

- **6.4 Final quality gate & human sign-off**
- Run full checks: `npm run lint`, `npm test`, `npm run test:e2e`, `npm run build` (including the new TUI package build).
- Ask you for a final manual session:
  - Run a few end-to-end flows (stateful/stateless, interactive/non-interactive TUI).
  - Confirm the data shown in the TUI matches your expectations and that the UX is acceptable for daily use.

## 7. Commit & Execution Guidelines

- Keep changes in **small, reviewable slices** that correspond roughly to subsections above (e.g. one commit for "add entities + migration", another for "wire telemetry into SquadService").
- Ensure **every commit** passes lint + unit tests; run e2e tests at least per phase or whenever MCP contracts or CLI behavior changes.
- Involve additional agents (e.g. `systems-architect`, `qa-specialist`, `frontend-developer`) only for **design/review and test-planning**, not for direct code generation, and capture any non-obvious decisions in short comments or docs.

### To-dos

- [ ] Implement SQLite telemetry (entities, TypeORM config, SquadTelemetryService) and wire it into SquadService and MCP contracts with tests and a manual DB sanity check.
- [ ] Create the gs-squad-dashboard CLI package with read-only better-sqlite3 access, polling, and an Ink-based view-only dashboard plus manual UX review.
- [ ] Add --interactive mode, PTY integration, and pinned-orchestrator behavior to the TUI, with env validation and manual interactive session testing.
- [ ] Add filters, UX robustness improvements, and documentation for telemetry, TUI usage, and configuration env vars, then run full test/build suite.
- [ ] Locate and review orchestrator-rules.mdc, reconcile it with the Phase 02 blueprint and current MCP contracts, and adjust detailed design if needed before coding.
- [ ] Maintain atomic, always-green commits across phases, extending or adding tests as functionality grows and ensuring lint/unit/e2e gates stay passing.